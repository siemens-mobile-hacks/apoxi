<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>APOXI: NiSharedPtr&lt; X &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.6-NO -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="classes.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
  </ul></div>
<h1>NiSharedPtr&lt; X &gt; Class Template Reference</h1><!-- doxytag: class="NiSharedPtr" --><code>#include &lt;<a class="el" href="NiSharedPtr_8hpp-source.html">Apoxi/Auxiliary/NiSharedPtr.hpp</a>&gt;</code>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">X *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNiSharedPtr.html#d94c3d349a5a503c3d394842e1765f50">Get</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the encapsulated pointer. Avoid using this method if possible.  <a href="#d94c3d349a5a503c3d394842e1765f50"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOLEAN&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNiSharedPtr.html#ffb2b48138acd5aca704de6e76da9d09">IsValid</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks whether this smart pointer actually points to an object.  <a href="#ffb2b48138acd5aca704de6e76da9d09"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNiSharedPtr.html#f76369eb4a1173dbdaf16e0d4d517e1a">NiSharedPtr</a> (const <a class="el" href="classNiSharedPtr.html">NiSharedPtr</a> &amp;r)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor.  <a href="#f76369eb4a1173dbdaf16e0d4d517e1a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNiSharedPtr.html#d91fc7ed73e320c68e8e5585f7026548">NiSharedPtr</a> (X *<a class="el" href="SetPixel__8Bpp_8cpp.html#46437c19939054adc55f18b95fc35b3d">p</a>=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs a smart-pointer for pointer p.  <a href="#d91fc7ed73e320c68e8e5585f7026548"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">X &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNiSharedPtr.html#08512fdccdb1f22b4f9c378b565558d7">operator *</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">X *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNiSharedPtr.html#ae08c232a9228fd95f11a48b301c29c3">operator-&gt;</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classNiSharedPtr.html">NiSharedPtr</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNiSharedPtr.html#f4090b21952810d4e052b6a40ba493ba">operator=</a> (const <a class="el" href="classNiSharedPtr.html">NiSharedPtr</a> &amp;r)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment operator.  <a href="#f4090b21952810d4e052b6a40ba493ba"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNiSharedPtr.html#85bf4f5194eeda9b29cd8e35b1b340fe">Release</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOLEAN&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNiSharedPtr.html#20377faffc08c104492349b00ae93b2f">Unique</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tells if the encapsulated pointer is referenced exactly once.  <a href="#20377faffc08c104492349b00ae93b2f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNiSharedPtr.html#a3c8c55900a05226d27fee2ab98d7c15">~NiSharedPtr</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructs the smart-pointer.  <a href="#a3c8c55900a05226d27fee2ab98d7c15"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>ItemRef</b></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename X&gt;<br>
 class NiSharedPtr&lt; X &gt;</h3>

Template class <a class="el" href="classNiSharedPtr.html">NiSharedPtr</a> implements a shared reference-counting non-intrusive smart-pointer. The smart-pointer is non-intrusive with respect to the objects that get reference counted, i.e. the objects don't have to be derived from some dedicated base-class and may stay as they are. For this, the smart-pointer in addition to the pointer for the counted object controls a counter, too. Since the target compilers do not all support member templates (we would need the templated copy constructor and templated assignment operator) there is no way to cast an instance of the smart-pointer to a related instance of another smart-pointer. APOXI also provides an intrusive smart-pointer called <a class="el" href="classSharedPtr.html">SharedPtr</a>. This smart-pointer on the one hand requires the reference counted object to be derived from <a class="el" href="classReferableObject.html">ReferableObject</a> but on the other hand for this provides the possibility to cast an instance of the smart-pointer to a related instance of another smart-pointer with some effort. For details on this please have a look in the documentation of class <a class="el" href="classSharedPtr.html">SharedPtr</a>. 
<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="d91fc7ed73e320c68e8e5585f7026548"></a><!-- doxytag: member="NiSharedPtr::NiSharedPtr" ref="d91fc7ed73e320c68e8e5585f7026548" args="(X *p=0)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename X&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classNiSharedPtr.html">NiSharedPtr</a>&lt; X &gt;::<a class="el" href="classNiSharedPtr.html">NiSharedPtr</a>           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">X *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>p</em> = <code>0</code>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline, explicit]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Constructs a smart-pointer for pointer p. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a3c8c55900a05226d27fee2ab98d7c15"></a><!-- doxytag: member="NiSharedPtr::~NiSharedPtr" ref="a3c8c55900a05226d27fee2ab98d7c15" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename X&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classNiSharedPtr.html">NiSharedPtr</a>&lt; X &gt;::~<a class="el" href="classNiSharedPtr.html">NiSharedPtr</a>           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Destructs the smart-pointer. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="f76369eb4a1173dbdaf16e0d4d517e1a"></a><!-- doxytag: member="NiSharedPtr::NiSharedPtr" ref="f76369eb4a1173dbdaf16e0d4d517e1a" args="(const NiSharedPtr &amp;r)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename X&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classNiSharedPtr.html">NiSharedPtr</a>&lt; X &gt;::<a class="el" href="classNiSharedPtr.html">NiSharedPtr</a>           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNiSharedPtr.html">NiSharedPtr</a>&lt; X &gt; &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>r</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Copy constructor. 
<p>
    </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="d94c3d349a5a503c3d394842e1765f50"></a><!-- doxytag: member="NiSharedPtr::Get" ref="d94c3d349a5a503c3d394842e1765f50" args="() const " --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename X&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">X* <a class="el" href="classNiSharedPtr.html">NiSharedPtr</a>&lt; X &gt;::Get           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the encapsulated pointer. Avoid using this method if possible. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="ffb2b48138acd5aca704de6e76da9d09"></a><!-- doxytag: member="NiSharedPtr::IsValid" ref="ffb2b48138acd5aca704de6e76da9d09" args="() const " --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename X&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">BOOLEAN <a class="el" href="classNiSharedPtr.html">NiSharedPtr</a>&lt; X &gt;::IsValid           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Checks whether this smart pointer actually points to an object. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="08512fdccdb1f22b4f9c378b565558d7"></a><!-- doxytag: member="NiSharedPtr::operator *" ref="08512fdccdb1f22b4f9c378b565558d7" args="() const " --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename X&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">X&amp; <a class="el" href="classNiSharedPtr.html">NiSharedPtr</a>&lt; X &gt;::operator *           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Dereferencing operator to access the object the smart-pointer points to. Note that an assertion will hold if the smart-pointer does actually not point to an object! You can use the methods of the underlying instance like this: <pre>
            <code>(*smart_ptr).memberfun()</code>
        </pre>     </td>
  </tr>
</table>
<a class="anchor" name="ae08c232a9228fd95f11a48b301c29c3"></a><!-- doxytag: member="NiSharedPtr::operator-&gt;" ref="ae08c232a9228fd95f11a48b301c29c3" args="() const " --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename X&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">X* <a class="el" href="classNiSharedPtr.html">NiSharedPtr</a>&lt; X &gt;::operator-&gt;           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Member selection operator to access a member of the object the smart-pointer points to. Note that an assertion will hold if the smart pointer does actually not point to an object! You can use the methods of the underlying instance like this: <pre>
            <code>smart_ptr-&gt;memberfun()</code>
        </pre>     </td>
  </tr>
</table>
<a class="anchor" name="f4090b21952810d4e052b6a40ba493ba"></a><!-- doxytag: member="NiSharedPtr::operator=" ref="f4090b21952810d4e052b6a40ba493ba" args="(const NiSharedPtr &amp;r)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename X&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classNiSharedPtr.html">NiSharedPtr</a>&amp; <a class="el" href="classNiSharedPtr.html">NiSharedPtr</a>&lt; X &gt;::operator=           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNiSharedPtr.html">NiSharedPtr</a>&lt; X &gt; &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>r</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Assignment operator. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="85bf4f5194eeda9b29cd8e35b1b340fe"></a><!-- doxytag: member="NiSharedPtr::Release" ref="85bf4f5194eeda9b29cd8e35b1b340fe" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename X&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="classNiSharedPtr.html">NiSharedPtr</a>&lt; X &gt;::Release           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Releases the reference counted object and deletes it if this was the last reference.     </td>
  </tr>
</table>
<a class="anchor" name="20377faffc08c104492349b00ae93b2f"></a><!-- doxytag: member="NiSharedPtr::Unique" ref="20377faffc08c104492349b00ae93b2f" args="() const " --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename X&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">BOOLEAN <a class="el" href="classNiSharedPtr.html">NiSharedPtr</a>&lt; X &gt;::Unique           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Tells if the encapsulated pointer is referenced exactly once. 
<p>
    </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following file:<ul>
<li>Auxiliary/<a class="el" href="NiSharedPtr_8hpp-source.html">NiSharedPtr.hpp</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Wed Jan 25 01:31:32 2006 for APOXI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.6-NO </small></address>
</body>
</html>
