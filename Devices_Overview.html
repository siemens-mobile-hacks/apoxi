<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Devices Overview</title>
<style type="text/css">
<!--
.Stil1 {
	font-family: Verdana, Arial, Helvetica, sans-serif;
	font-size: xx-large;
	font-weight: bold;
}
.Stil4 {
	font-size: large;
	font-family: Verdana, Arial, Helvetica, sans-serif;
	font-weight: bold;
}
.Stil6 {font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 12px;}
.Stil8 {font-family: Verdana, Arial, Helvetica, sans-serif; font-size: larger;}
.Stil11 {font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 12px; font-weight: bold; }
.Stil12 {font-family: "Courier New", Courier, mono}
-->
</style>
</head>

<body>
<div align="center">
  <p align="justify" class="Stil1">Devices Overview </p>
  <p align="justify" class="Stil4">1 Introduction</p>
  <p align="justify" class="Stil6">Devices module defines the common interface to the devices such as display, keyboard and real time clock, 
  camera, etc.</p>
  <p align="justify" class="Stil6">    The class Device is a defined abstract interface, where the implementation is hardware-dependant. When  
    changing the implementation of a device, it must be assured that the public interface is not changed. It is not 
    necessary that the class stays binary compatible, as usually APOXI must be compiled anyway when major 
changes of devices are done.</p>
  <p align="justify" class="Stil4">2 Keyboard</p>
  <p align="justify" class="Stil6">The Keyboard in APOXI is configurable and there can be different keypads which differ in the number of keys and 
  the position of keys as shown in the following figure.</p>
  
<div align="justify">
  <table width="98%"  border="1" align="center" cellpadding="0" cellspacing="0" bordercolor="#000000">
    <tr>
      <td height="261"><div align="center"><img src="figures/Keypads.png" width="297" height="226"></div></td>
    </tr>
  </table>
</div>
  <p align="justify" class="Stil8">2.1 Handling of keys</p>
  <p align="justify" class="Stil6">The keyboard driver provides the SDL signals indicating the key press and key release. It also provides a 
    timestamp giving the time when the key has been pressed or released. All other events from the keyboard are 
  handled by the keyboard device.</p>
  <p align="justify" class="Stil6">    The applications can get the key states in two ways as described in the following:</p>
  <p align="justify" class="Stil6">    1) Applications can ask for the key state of a particular key. An example for this key state checking is given in the 
    following code:</p>
  <p align="justify" class="Stil6">     <span class="Stil12">Keyboard::GetKeyState(KeyboardConfig::GetNumber(5))</span></p>
  <p align="justify" class="Stil6">    2) Whenever there is a keystate change, the keyboard device will send the corresponding message to the 
    application. To receive these messages, applications should register for them. The messages send from the 
    keyboard to applications are described in the following:</p>
  <p align="justify" class="Stil6"><span class="Stil11">Key Down Message</span></p>
  <p align="justify" class="Stil6">  This message is send to the application each time the user presses a key.</p>
  <p align="justify" class="Stil6"><span class="Stil11"> Key Up Message</span></p>
  <p align="justify" class="Stil6">    This message is send to the application each time a key is pressed.</p>
  <p align="justify" class="Stil6"><span class="Stil11">    Long Key Press Message</span></p>
  <p align="justify" class="Stil6">    This message is send to the application when ever a particular key is pressed for a specified duration of time. For 
    example, suppose long key press time period has been specified as 1000 Millie seconds. In such case a long key press message will be send to the application whenever user presses a key and not releases it until 1000 
    milliseconds. The time limit for the long key press is defined in the <em>KeyboardConfig</em>.</p>
  <p align="justify" class="Stil6"><strong>Very Long Key Press Message</strong></p>
  <p align="justify" class="Stil6">    This message will be send to the application when the user presses a particular key for a very long time period. 
This time period is specified in the <em>KeyboardConfig</em>.</p>
  <p align="justify" class="Stil6"><strong>    Key Auto Repeat Message</strong></p>
  <p align="justify" class="Stil6">    This message will be send when the user presses a key for a very long time period. It indicates the same effect 
    as pressing a key severel times,i.e, auto repetitions of the key press. The application can use Key Auto Repeat 
    information for some special actions. For example it can be used to move down or up through menu items by 
    pressing the down or up key for a long time. The auto repeat delay and the auto repeat intervals are also specified 
in the <em>KeyboardCofig</em>.</p>
  <p align="justify" class="Stil6">    <strong>Key locking</strong></p>
  
<div align="justify">
      <ul>
        <li>
          <span class="Stil6"><strong>Unlocked</strong>: When the keyboard is in unlocked state, all the key messages will be sent out to the application when ever there is a keystate change for each key.</span></li>
          <li>
            <span class="Stil6"><strong>Locked</strong>: If the keyboard is locked, normal key messages will not be send out. In such locked state a Locked Key message will be send out whenever user presses a key. It is necessary for the applications to register for such a message for unlocking the keypad later.</span></li>
      </ul>
</div>
  <p align="justify"><span class="Stil11">Keyboard illumination</span></p>
  <p align="justify" class="Stil6">  There are three states of keyboard illumination as listed in the following:</p>
  
<ul><li><div align="left" class="Stil6">
      <div align="justify"><strong>On</strong>: The illumination of the keyboard will be always on</div>
    </div>
  </li>
    <li>
      <div align="left" class="Stil6">
        <div align="justify"><strong>Off</strong>: The illumination of the keyboard will be always off</div>
      </div>
    </li>
    <li>
      <div align="left" class="Stil6">
        <div align="justify"><strong>Auto</strong>: If the keyboard illumination state is auto, then there will be a pre-defined time-out period. If there is no keystate change within that time-out period, the keyboard illumination will be automatically turned off. The illumination will again turned on, whenever there is a keystate change in the keyboard.</div>
      </div>
    </li>
  </ul>
  <p align="justify" class="Stil11">Multikey mode
</p>
  <p align="justify" class="Stil6">Key board device supports multi key mode. When multi key mode is not enabled only a single key press message 
    will be send to the application at a time even if the user presses more than one keys at a time. This is shown in 
  the following figure 1.</p>
  
<div align="justify">
  <table width="98%"  border="1" align="center" cellpadding="0" cellspacing="0" bordercolor="#000000">
    <tr>
      <td height="198"><div align="center"><img src="figures/Single_Key_Mode.png" width="513" height="162"></div></td>
    </tr>
  </table>
</div>
  <p align="justify" class="Stil11">Figure&nbsp;1. Single key mode</p>
  <p align="justify" class="Stil6">As shown in Figure 1 key2 down message will be send to the application only after the release of the 
  Key1 even though the key2 has been pressed before the release of key1.</p>
  <p align="justify" class="Stil6">    When multikey mode is enabled, it is possible for the applications to get the message indicating multikey press 
    when user presses more than one keys at the same time. This is illustrated in Figure 2.</p>
  
<div align="justify">
  <table width="98%"  border="1" align="center" cellpadding="0" cellspacing="0" bordercolor="#000000">
    <tr>
      <td height="236"><div align="center"><img src="figures/Multi_Key_Mode.png" width="475" height="195"></div></td>
    </tr>
  </table>
</div>
  <p align="justify" class="Stil11">Figure&nbsp;1 MultiKey mode</p>
  <p align="justify" class="Stil6">As shown in Figure 2, when key2 is pressed before the release of key1, both key1 and key2 down messages 
  will be send to the application.</p>
  <p align="justify" class="Stil4">3 Display</p>
  <p align="justify" class="Stil6">Display device provides methods for accessing the display in a generic way. The direct use of the display device 
  bypasses the APOXI window system.</p>
  <p align="justify" class="Stil6">    The display device use an internal frame buffer where all the drawings are done. After finishing the drawingprocess 
    those parts which have changed on the frame buffer are copied to the display buffer by invoking 
    Display::Refresh. The area which has been changed is defined by the so called blitting rectangle. The display has 
two buffer modes, they are:</p>
  
<div align="justify">
      <ul>
        <li class="Stil6">
          <strong>Double buffering</strong>: Provides asynchronous support</li>
          <li class="Stil6">
            <strong>Single buffering</strong>: Provides synchronous support</li>
      </ul>
</div>
  <p align="justify"><span class="Stil4">4 Video channel</span></p>
  <p align="justify" class="Stil6">    The video channel is a separate part of the display device and can be retrieved by invoking 
  Display::GetVideoChannel. Video channel is for playing video. </p>
  <p align="justify" class="Stil6"> It is generally assumed that the content to be displayed via video channel is located in a separate buffer (or certain 
    number of buffers), the process of transferring this content to the display is called rendering and is typically 
    assisted by hardware (e.g. a companion chip). Rendering includes some transformation like color conversion, 
    resizing, rotation, flipping/mirroring, clipping/cropping. Most crucial for rendering is the correct mixing of the 
    content in this channel with the display content. This operation is called overlaying.</p>
  <p align="justify" class="Stil6"><span class="Stil4">5 Led</span></p>
  <p align="justify" class="Stil6"><span class="Stil4">  </span>Led is the APOXI device abstraction interface for LED hardware driver. APOXI Led Provides the following 
functionalities:</p>
  
<ul><li><div align="left" class="Stil6">
      <div align="justify"><strong>Multi color Suppor</strong>t: Led Provides multi color (RGB) support. This multi color support is hardware dependent i.e, Led will not be able to support multi color if the hardware does not support multi color.</div>
    </div>
    </li>
    <li>
      <div align="left" class="Stil6">
        <div align="justify"><strong>Turn on/off Led</strong>: It is possible to turn the LED on ad off</div>
      </div>
    </li>
    <li>
      <div align="left" class="Stil6">
        <div align="justify"><strong>Fading the LED on and/or off</strong></div>
      </div>
    </li>
    <li>
      <div align="left" class="Stil6">
        <div align="justify"><strong>Streaming</strong>: Streaming is also supported in APOXI Led. It is the creation of color streams for special illumination scenarios.</div>
      </div>
    </li>
  </ul>
  <p align="justify" class="Stil6"><span class="Stil4">6 Real Time Clock</span></p>
  <p align="justify" class="Stil6">    RealTimeClock is the APOXI device abstraction interface for RTC hardware driver. The Real Time Clock provides 
  the following functionalities:</p>
  
<div align="justify">
      <ul>
        <li class="Stil6">
          <strong>Set Date and Time</strong>: Sets the date and time</li>
          <li class="Stil6">
            <strong>Get Date and Time</strong>: Gets the current date and time</li>
          <li class="Stil6">
            <strong>Handling of single Alarm</strong>:This interface helps to handle single alarm</li>
      </ul>
</div>
  <p align="justify" class="Stil6"><em><strong>Note:</strong></em> <em>Kernel module provides an interface called AlarmManager for handling multiple alarms</em></p>
  <p align="justify" class="Stil4">7 Charger</p>
  <p align="justify" class="Stil6">The charger interface in APOXI provides the following functionalities:</p>
  
<ul class="Stil6"><li><div align="left" class="Stil6">
      <div align="justify"><strong>Provides status of charger</strong>: The application can ask for the status of the charger. The status includes:</div>
    </div>
      
        <div align="justify">
            <ul>
              <li>Disabled: This status indicates that the charger has not been initilized</li>
                <li>WaitingForConnection: This means the charger is not connected yet</li>
                <li>ConnectedAndCharging: This indicates that the charger is connected and charging is active</li>
                <li>ConnectedAndBatteryFull: This indicates that the charger is connected but charging is inactive because the battery is full </li>
                <li>DisconnectedAndBatteryFull: This status indicates that the battery is full and the charger has recently been removed</li>
                <li>DisconnectedAndBatteryNotFull: This status indicates that the battery is not full and the charger has recently been removed </li>
            </ul>
    </div>
    </li>
    <li>
      <div align="justify"><strong>Provides the Capacity of charger</strong>: This indicates how much capacity is left and is expressed as percentage of full capacity. Value range: [0..100]
      </div>
    </li>
</ul>
  <p align="justify" class="Stil6">Some of message interfaces provided by charger are listed in the following:
  </p>
  
<div align="justify">
      <ul>
        <li>
          <span class="Stil6"><strong>ChargerRemoved</strong>: This message is send to the application when the charger is removed</span></li>
          <li>
            <span class="Stil6"><strong>ChargeBattery</strong>: This message is send when the battery is charging</span></li>
          <li>
            <span class="Stil6"><strong>LowBattery</strong>: This message is send to the application when the battery charge is low</span></li>
          <li>
            <span class="Stil6"><strong>BatteryEmpty</strong>: This message is send to the application when the battery is empty</span></li>
          <li>
            <span class="Stil6"><strong>ChargeEndBatteryIsFull</strong>: This message will be send to the application when the battery is full</span>
          </li>
      </ul>
</div>
  <p align="justify" class="Stil4">8 Camera</p>
  <p align="justify" class="Stil6">Camera device is for accessing hardware cameras. The application has the possibility to obtain a special camera, 
    which is bound to the hardware ID. The camera object is defined statically in the camera configuration 
    (CameraConfig). For each camera device one camera object exists. Functionalities provided by the Camera 
  device are described in the following:</p>
  
<div align="justify">
      <ul>
        <li class="Stil6">
          <strong>Setting up ViewFinderSize and Display</strong>: When enabling the view finder, the viewing picture is scaled to the defined rectangle, which usually corresponds to the size of the view finder window. Nevertheless, the view finder rectangle can be limited in scaling due to hardware restrictions. </li>
          <li class="Stil6">
              <strong>Setting up ViewFinder</strong>: For enabling, disabling and taking a picture, the Method <em>SetViewFinderCommand()</em> can be used. The given parameter indicates the command in which state the ViewFinder should be set. The different states that can be set in the ViewFinder are:
                  <ul>
                    <li>Disabled: It is the default state, where the <em>ViewFinder</em> is disabled.</li>
                      <li>Enabled: This means that the viewfinder is enabled and is drawing on the given display.</li>
                      <li>Capture ViewFinder: If ViewFinder is set to <em>CaptureViewFinder</em>, a picture is taken and will be processed by the camera device (e.g.converting to JPEG) and copied into the given buffer.</li>
                      <li>Show Captured Image: Displays the last captured Image again on the <em>ViewFinder</em>. This setting is optional. It is hardware dependent feature.</li>
                      <li>Freeze view finder: Stops of the <em>ViewFinder</em> (last frame is displayed). In the freezed state no image processing will be done. This is feature is hardware dependent and is optional.</li>
                  </ul>
        </li>
          <li class="Stil6">
            <strong>Setting Color Format</strong>: Certain cameras may deliver different color formats, like RAW YUV data or encoded JPEG data. The APOXI Camera API allows to select a supported color format. In APOXI camera, it is possible to change and get the image data or color type. The method <em>GetSupportedColorFormats</em> delivers an array of the supported color formats of the companion chip.</li>
          <li class="Stil6">
            <strong>Image Size</strong>: The image size returned by the camera can be set via <em>SetImageSize</em>. It determines the size of the image that will be returned natively, without resizing through the viewfinder. If the requested image size is not supported, the call is ignored and FALSE is returned. All possible image sizes can be retrieved by calling the method <em>GetSupportedImageSizes()</em>.</li>
          <li class="Stil6">
            <strong>Setting up Camera Properties</strong>: Certain camera properties such as brightness and contrast, can be set via a so called property. The property itself consist of property name, a property type and a property value.</li>
          <li class="Stil6">
            <strong>Twilight Mode</strong>: By enabling twilight mode, the sensitivity of the companion chip will be increased. This results in better images in certain light conditions.</li>
          <li class="Stil6">
            <strong>Mask</strong>: Some companion chips support masking the image. In APOXI there is a comfortable way to use transparency and even alpha blending. Masking and Blending is done via a DeviceContext. Internally there is blending mask which will be used for blending objects over the camera viewfinder. Therefore the user does not need to take care about the blending mask.</li>
          <li class="Stil6">
            <strong>Anti-Flicker Mode</strong>: To reduce flicker problems, the anti flicker mode can be set to 50 or 60 Hz. This prevents dark streaks in the image when shooting pictures in electric light powered by either 50 or 60 Hz currents.</li>
          <li class="Stil6">
            <strong>Flash</strong>: The on board flash can be enabled or disabled.</li>
          <li class="Stil6">
            <strong>Zoom</strong>: In camera device it is possible to set the zoom levels.</li>
          <li class="Stil6">
            <strong>Transformation</strong>: The transformation includes the rotation of the image in 90&deg; steps, including mirroring.</li>
      </ul>
</div>
  <p align="justify" class="Stil6"><span class="Stil4">9 Video Camera</span></p>
  <p align="justify" class="Stil6">    The video camera device is derived from camera and offers all functionality of a still camera. In addition it has an 
    extended interface for video capturing functionality. The functionalities of the video camera are listed in the 
following:</p>
  
<div align="justify">
      <ul>
        <li class="Stil6">
          <strong>Video Capturing</strong>: Before starting capturing, some user defined values need to be set. These settings includes settings for still camera interface, such as setting up view finder, setting Image size, view finder size and display, color format, and additional parameters for video recording like size of the video.</li>
          <li class="Stil6">
            <strong>Registering Callback Functions</strong>: The application has to set the required callback functions for the video capturing.</li>
          <li class="Stil6">
            <strong>Setting up Capture Buffers</strong>: For video capturing a number of buffers are required. Those buffers can be both allocated and held by the device layer, or found on the companion chip.</li>
          <li class="Stil6">
            <strong>Starting and Stopping Recording</strong>: Methods are provided in Video Camera interface for starting and stopping the recording.</li>
      </ul>
</div>
</body>
</html>
