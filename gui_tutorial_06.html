<html>
	<head>
		<link href="doxygen.css" rel="stylesheet" type="text/css">
		<title>6 Drawable Objects</title>
	</head>
	
	<body>
		[ Previous: <a href="gui_tutorial_05.html">Controls</a> ] [ Next: <a href="gui_tutorial_07.html">Device Context</a> ]
		
		<h1>6 Drawable Objects</h1>
		
		<p>
			A drawable object has the following characteristics:
			<ul style="line-height: 150%">
				<li>has boundaries</li>
				<li>can receive messages</li>
				<li>can be drawn</li>
			</ul>
			
			In opposite to a control a drawable-object has no distinction between a frame-area and client-area, also a drawable-object can never get the focus.		
		</p>
		
		<h2>6.1 TextLine</h2>
		
		<p>
			The <a href="classTextLine.html">TextLine</a> represents a text aligned into a line, which may have a custom font, textformat and color. 
		</p>
		
		<h2>6.2 AnimatedTextLine</h2>
		
		<p>
			The class <a href="classAnimatedTextLinehtml">AnimatedTextLine</a> extends the class <a href="classTextLinehtml">TextLine</a>
			with the ability of text-scrolling, if the text does not fit into the given width.	
		</p>
		
		<h2>6.3 TextBox</h3>
		
		<p>
			The <a href="classTextBox.html">TextBox</a> represents a text aligned into
			a box, where an automatic
			wrapping of the text is done. The text may have a custom font,
			textformat and color. Note that if the text is too long to fit
			into the box, the text will be clipped at the bottom. If a
			scrollbar is needed and hence also an interaction with the
			user, the controls <a href="classTextList.html">TextList</a> or <a href="classMultiLineEditor.html">MultiLineEditor</a>
			(used in read-only-mode) should be used.	
		</p>

		<h2>6.4 ProgressBar</h3>
		
		<p>
			The <a href="classProgressBar.html">ProgressBar</a>  indicates a percentual progress. The look may be adjusted by writing an own view as part of a theme. An available reference-implementation is available under
			Apoxi/GlobalThemes/DefaultTheme/DefaultProgressBarView.*
		</p>
		
		<p>
			<img src="pics/progress_bar.gif" alt="ProgressBar"/>
		</p>
		
		<h2>6.5 PositionIndicator</h3>
		
		<p>
			Indicates the position of a range, which is partly visible.
			The range is defined by a minimum value and a maximum value,
			the current position by a value. Additionally it must be defined,
			how many values can be visible. A position-indicator can be
			aligned horizontal or vertical.
		</p>
		
		<p>
			<img src="pics/position_indicator.gif" alt="PositionIndicator"/>
		</p>
		
		<p>
  			The look may be adjusted by writing an own view as part of a theme. An available reference-implementation is available under: 
  			<ul style="line-height: 150%">
  				<li>Apoxi/GlobalThemes/DefaultTheme/DefaultPositionIndicatorView.*</li>
				<li>Apoxi/GlobalThemes/FoggyTheme/FoggyPositionIndicatorView.*</li>
			</ul>
		</p>
		
		<h2>6.6 ImageBox</h3>
		
		<p>
			An <a href="classImageBox.html">ImageBox</a> contains any kind of image represented either
			by a bitmap-resource or an image-obtainer. A bitmap-resource is
			implemented by <a href="classBitmap.html">BitmapRes</a>, an image-obtainer by the
			class <a href="classImageObtainer.html">ImageObtainer</a>. It is strongly recommended to use
			the image box for displaying images, as if necessary the image box is capable of
			decoding the images in a separate thread. This
			assures that the application is not blocked during the decoding of an image.
		</p>
		
		<p>
			<img src="pics/image_box.gif" alt="ImageBox"/>
		</p>
		
		<h3>6.6.1 BitmapRes </h3>
		
		<p>
			A bitmap-resource represents an internal bitmap of APOXI. Every bitmap-resource is organized in the same way as the display. This allows a very fast drawing but has the drawback of needing more memory than e. g. a JPEG-image. All bitmap-resources are generated by the APOXI-tool Resource-Compiler. See APOXI_Tools_ResourceCompiler.pdf for more details.
		</p>
		
		<p>
			Example: A bitmap-resource is added to an image-box.
		</p>
		<b>MyWindow.hpp</b>
		<pre>
class MyWindow : public <a href="classWindow.html">Window</a> {
	typedef <a href="classWindow.html">Window</a> Base;

	public:
		void Init();

	private:
		<a href="classImageBox.html">ImageBox</a> m_image_box;
};</pre>

		<b>MyWindow.cpp:</b>
		<pre>
#include &lt;Config/Resources/img1.hpp&gt;

void MyWindow::Init()
{
	Base::Init();
	m_image_box.Init(this, &img1);
}</pre>
		<h3>6.6.2 ImageObtainer</h3>
		
		<p>
			An image-obtainer may contain any instance of the class
			<a href="classImage.html">Image</a>, which is the base for e. g. JPEG-images and GIF-images. An image-obtainer does a reference-counting, hence when all image-obtainers referring to one instance of an image are destructed and the image-obtainer has been initialized to obtain a disposable image, the image itself will get deleted too:
		<p>
	
		<p>
			<img src="pics/image_obtainer.gif" alt="image obtainers"/>
		</p>
		
		<p>
		Example 1: An animation is added to an image-box. The delay between the frames is set to 200 milliseconds in this example.
		</p>
		<b>MyWindow.hpp</b>
		<pre>
class MyWindow : public <a href="classWindow.html">Window</a> {
	typedef <a href="classWindow.html">Window</a> Base;

	public:
		void Init();

	private:
		<a href="classNativeImage.html">NativeImage</a> m_native_img;
		<a href="classImageBox.html">ImageBox</a> m_image_box;
};</pre>

		<b>MyWindow.cpp:</b>
		<pre>
#include &lt;Config/Resources/img1.hpp&gt;		// bitmap-resource 1
#include &lt;Config/Resources/img2.hpp&gt;		// bitmap-resource 2
#include &lt;Config/Resources/img3.hpp&gt;		// bitmap-resource 3

const BitmapRes* const c_img_anim[] = { &img1, &img2, &img3 };

void MyWindow::Init()
{
	Base::Init();
	m_native_img.Init(c_img_anim, 3, 200);
	m_image_box.Init(this, ImageObtainer(&m_native_img));
}</pre>

		<p>
			Example 2: A JPEG-image is added to an image-box. A JPEG-image reads from a binary data stream, which is explained in detail in the next chapter.
		</p>
		
		<b>MyWindow.hpp</b>
		<pre>
class MyWindow : public <a href="classWindow.html">Window</a> {
	typedef <a href="classWindow.html">Window</a> Base;

	public:
		void Init();

	private:
		<a href="classJpegImage.html">JpegImage</a> m_jpeg_img;
		<a href="classImageBox.html">ImageBox</a> m_image_box;
};</pre>

		<b>MyWindow.cpp:</b>
		<pre>
void MyWindow::Init()
{
	Base::Init();
	
	// c_jpeg-data must point to a buffer containing the jpeg-data,
	// c_data_length provides the length of the data in bytes	
	const RamData* ram_data = RamData::CreateInstance(c_jpeg_data, c_data_length);
	m_jpeg_img.Init(ram_data);
	m_image_box.Init(this, ImageObtainer(&m_jpeg_img));
}</pre>

		<p>
			As the examples show it is recommended to allocate an
			image-obtainer on the stack, because there is no need to keep the image-obtainer alive
			after passing it to an object which is responsible for the image.
		</p>
		
		<h3>6.6.3 Image Buffering</h3>
		<p>
			An image box offers the possibility to buffer images and animations
			for performance reasons. 
			If an animation can not be buffered completely, the image box
			automatically tries to buffer at least two frames, which are
			necessary to display all kind of animations correctly.
			This means that the animation is decoded synchronously which might lead to 
			a less responsive GUI. But also in this case it is always possible
			to interrupt the decoding at any time.
		</p>
		
		<h3>6.6.4 Binary Data</h3>
		
		<p>
			The JPEG-image and most other image classes may read the data of the image from a binary data stream, represented by the class
			<a href="classBinData.html">BinData</a>. 
		</p>
		
		<p>
			<a href="classBinData.html">BinData</a> defines an interface to access binary data in a
			way that releases the user from memory management.
			Usually an instance is created from one class but
			handled and obtained from another class. Therefor
			instances may not be constructed directly using a
			constructor. Any derived class provides a static method
			CreateInstance(…) to create an instance:
		<p>
		<pre>
const RamData* ram_data = RamData::CreateInstance(c_jpeg_data, c_data_length);</pre>

		<div class="important">
			After passing a pointer to a binary data to any object
			(e. g. to an instance of the class JpegImage),
			the binary data is obtained by this object per definition
			and hence the releasing of the binary data is done by the object
			itself by invoking ReleaseInstance().
			Hence never release a binary data after passing it to another object.
		</div>
		
		<p>
			Per default APOXI offers the following kind of binary data:
			<ul style="line-height: 150%">
				<li><b>RamData:</b> provides a <a href="classBinData.html">BinData</a> interface to a
						dynamically allocated or statically defined RAM memory area.
						Note that <a href="classRamData.html">RamData</a> does not touch the memory area itself when being destructed.</li>
				<li><b>BufferedData:</b> Extends the class <a href="classRamData.html">RamData</a> to
						provide an internal copy of the buffer passed
						by CreateInstance. The internal buffer is
						allocated in CreateInstance and destroyed
						in ReleaseInstance. Hence when using
						this class the application-programmer may delete its
						buffer immediatly	after invoking CreateInstance
						because the buffer is copied to the internal buffer.</li>
				<li><b>FileBinData:</b> Allows to read from a file.</li>
			</ul>
		</p>
		
		<h3>6.6.5 Synchronous Drawing</h3>
		
		<p>
			Usually applications like WAP and JAVA use a synchronous drawing mechanism (for the
			difference between synchronous drawing and asynchronous drawing have a look
			at <a href="gui_tutorial_07.html">chapter 7.3</a>). The image-box draws itself
			in an asynchronous way, which makes it necessary to take care about some issues
			when the application does the drawing in a synchronous way.
		</p>
		
		<p>
			As example for possible issues and how to solve them a WAP-application is chosen.
			A typical WAP-application has a kind of rendering-engine, which reads the WML-content
			and builds its own object model. The rendering-engine might also draw the content
			as soon as possible in a synchronous way. Usually APOXI device-context methods like
			<em>DrawText()</em> are used. When it comes to draw an image it is not recommended
			to use the method <em>Image::Draw</em> directly, as it blocks the rendering-engine
			and also does not take care about animations (see chapter 6.7.5 for details).
			Instead the following steps should be done:
			<ul>
				<li>Create an instance of the class <a href="classImageBox.html">ImageBox</a> with
					the WAP-browser-window as parent.</li>
				<li>Set the position and size of the image-box.</li>
			</ul>
			When the content must be rerendered because the size of the window has changed or
			the content had to be scrolled, the rendering-engine just has to assure that
			the position of the image-box is adjusted by invoking <em>ImageBox::SetPos()</em>.
		</p>
		
		<p>
			If a window A is opened above the WAP-browser-window, the WAP-browser-window will get
			invalidated if the window A will be closed. The invalidation results in invoking the
			method <em>WapWindow::OnPaint</em>. Per default in the method <em>Window::OnPaint</em>
			the embedded components (e. g. the image-boxes) are drawn. Usually the method OnPaint
			must be overwritten by the WAP-browser-window to trigger the redrawing of the content in
			a synchronous way. There are two solutions for doing this:
		</p>
		<b>Solution 1:</b>
<pre>
void WapWindow::OnPaint(const Rect& repaint_rect)
{
	Window::OnPaint(repaint_rect);
	m_rendering_engine->TriggerRedraw(...);
}</pre>
		<p>
			Solution 1 clears the window-content and draws
			all embedded components (e. g. image-boxes) in <em>Window::OnPaint()</em>.
			Afterwards the rendering-engine is triggered to redraw its content.
			In this case it is important that the rendering-engine does not
			clear the area where APOXI-components are already redrawn. As the
			rendering-engine has created the embedded components and also has set
			the position, this should be no problem.
		</p>

		<b> Solution 2:</b>
<pre>
void WapWindow::OnPaint(const Rect& repaint_rect)
{
	m_rendering_engine->TriggerRedraw(...);
	Window::OnPaint(repaint_rect);
}</pre>
		<p>
			In solution 2 the rendering-engine does the redrawing first and
			afterwards the embedded components are redrawn by Window::OnPaint.
			This allows the rendering-engine to clear variable areas without
			taking care about embedded components, as they are drawn later.
			It is important that when constructing an instance of the WAP-browser-window
			that the automatical clearing of the window-background is switched off
			by invoking <em>Window::SetAutoClearEnabled(FALSE)</em>, otherwise
			the drawn content from the rendering-engine would be cleared in <em>Window::OnPaint()</em>.
		</p>

		
		<h3>6.6.6 Using Image::ConvertToBitmap and Image::Draw</h3>

		<p>
			As already mentioned it is strongly recommended to use the image box for drawing
			images. Especially the correct displaying of transparent GIF-animations in a
			non-blocking way can get very difficult when using the image-classes directly by
			invoking Image::ConvertToBitmap() or Image::Draw(). Anyway there might be situations
			where it is useful to display images without using an image box.
		</p>
			
		<p>
			In APOXI the decoding and drawing of an image is done, when invoking the
			method Image::Draw(). It is important to be aware
			about the fact, that while decoding the image other
			applications inside the same application-container (represented by a thread)
			are blocked until the decoding has been finished. This is no problem for small
			images, which need only some milliseconds to decode, but it is not acceptable when having
			large images. The recommended way to solve this issue is to convert the image
			to a bitmap by the method Image::ConvertToBitmap().
			When invoking this method, the image is decoded by
			the APOXI Worker <a href="classThread.html">Thread</a> and converted to a bitmap.
			The APOXI Worker <a href="classThread.html">Thread</a> is a thread which may get 
			variable tasks from APOXI. When invoking
			Image::ConvertToBitmap() the application
			will be informed about the progress of the decoding
			by the message <a href="classImageDecodingProgressMsg.html">ImageDecodingProgressMsg</a>,
			which contains the progress. The decoding has been
			finished, if the progress has reached the value 100.
			It is recommended to give the user a visual feedback
			about the progress by using the drawable object
			<a href="classProgressBar.html">ProgressBar</a> or show the current state
			of the bitmap when getting the message <a href="classImageDecodingProgressMsg.html">ImageDecodingProgressMsg</a>.
			</li>
			<p>			
				Example: a JPEG-image is converted into a bitmap by the worker-thread. The progress of the converting is shown by displaying the bitmap in the method OnPaint(). It would also be possible to use a progress-bar, which must be set when catching the message <a href="classImageDecodingProgressMsg.html">ImageDecodingProgressMsg</a>.
			</p>
			<b>MyWindow.hpp</b>
			<pre>
class MyWindow : public <a href="classWindow.html">Window</a> {
     typedef <a href="classWindow.html">Window</a> Base;
    public:
        void Init();
    protected:
        virtual void OnOpen();
        virtual void OnClose();
        virtual BOOLEAN OnMessage(const Message& msg);
        virtual void OnPaint(const Rect& repaint_rect);
    private:
        <a href="classJpegImage.html">JpegImage</a> m_image;
        Bitmap* m_conv_bmp;
};</pre>

					<b>MyWindow.cpp</b>
					<pre>
#include "MyWindow.hpp"
void MyWindow::Init()
{
    Base::Init()
    m_image.Init(...);
    m_conv_img = 0;
}

void MyWindow::OnOpen()
{
    Base::OnOpen();
    GetApplication()->RegisterMessage(ImageDecodingProgressMsg::ID);      
    m_conv_bmp = new Bitmap(100, 50);

    if ((m_conv_bmp != 0) && m_conv_bmp->IsValid())
        m_image->ConvertToBitmap(&m_conv_bmp, 0, FALSE);
}

void MyWindow::OnClose()
{
    GetApplication()->UnregisterMessage(ImageDecodingProgressMsg::ID);
    m_image.StopDecoding();
    delete m_conv_bmp;
    m_conv_bmp = 0;
    Base::OnClose();
}

BOOLEAN MyWindow::OnMessage(const Message& msg)
{
    BOOLEAN dispatched = FALSE;
    if (msg.Id() == ImageDecodingProgressMsg::ID) {
        ImageDecodingProgressMsg* progress_msg;
        CastMsg(progress_msg, &msg);
        if (progress_msg->GetImage() == &m_image) {
           // trigger a redraw of the window
           Invalidate();
           // If a progress-bar should be used, the
           // progress could be set by
           // m_progress_bar.SetProgress(progress_msg->GetProgress());
           // and no invalidate is needed.
           dispatched = TRUE;
        }
    }

    if (!dispatched)
        dispatched = Base::OnMessage(msg);

    return dispatched;
}

void MyWindow::OnPaint(const Rect& repaint_rect)
{
    Base::OnPaint(repaint_rect);
    if (m_conv_bmp != 0) {
         <a href="classPaintDc.html">PaintDc</a> pdc(GetDeviceContext());
         pdc.DrawBitmap(0, 0, *m_conv_bmp);
    }
}</pre>

		<p>
			Before deleting the image or the bitmap it must be assured,
			that the decoding is stopped when the method
			ConvertToBitmap has been invoked before. This is
			done by <em>m_image.StopDecoding()</em>. Alternatively it
			would have been possible to invoke
			<em>m_image.WaitUntilDecodingIsFinished()</em>, which waits
			until the decoding is finished but does not block
			the message-flow of applications. It is also possible
			to ask the image whether it is decoded currently by
			invoking the method IsCurrentlyDecoded.
		</p>

		<h2>6.7 Implementation of a Customized Drawable Object</h2>
	
		<p>
			A drawable object should be created, which draws a rectangle with the text "MyDrawableObject" as content.
		</p>
		
		<b>MyDrawableObject.hpp</b>
		<pre>
class MyDrawableObjectView : public <a href="classDrawableObjectView.html">DrawableObjectView</a> {
	public:
		MyDrawableObjectView();
		virtual ~MyDrawableObjectView();
		virtual void Draw(const Component& component, DeviceContext* dc,
			const Rect& repaint_rect) const;
};

class MyDrawableObject : public <a href="classDrawableObject.html">DrawableObject</a> {
	public:
		MyDrawableObject(Control* parent);
		virtual ~MyDrawableObject();
		const WCHAR* GetText() const { return L"MyDrawableObject"; }

	private:
		static MyDrawableObjectView m_view;
};</pre>

		<b>MyDrawableObject.cpp:</b>
		<pre>
MyDrawableObjectView MyDrawableObject::m_view;

MyDrawableObjectView::MyDrawableObjectView () :
	DrawableObjectView(70, 20)
{
}

MyDrawableObjectView::~MyDrawableObjectView ()
{
}

void MyDrawableObjectView:: Draw(const Component& component, DeviceContext* dc,
	const Rect& repaint_rect) const
{
	const MyDrawableObject& my_obj = (const MyDrawableObject&)component;

	<a href="classPaintDc.html">PaintDc</a> pdc(dc);
	pdc.SetPenColor(Color::ClientForeground);
	pdc.DrawRect(my_obj.GetBoundingRect());
	pdc.DrawText(my_obj.GetLeft(), my_obj.GetTop(), my_obj.GetText());
}

MyDrawableObject::MyDrawableObject(Control* parent) :
	DrawableObject(parent, TRUE, &m_view)
{
}

MyDrawableObject::~MyDrawableObject()
{
}</pre>

		<p>
			Some notes to the implementation:
			<ul style="line-height: 150%">
				<li>When initializing a view, the default height and default
					width may be provided by the constructor. These parameters
					are respected when e. g. using the <a href="classLayouter.html">Layouter</a> in
					Control::OnLayoutClient().
					In the implementation of MyDrawableObjectView the
					drawable object has a default width of 70 and a default
					height of 20. A width and height of -1 indicate no
					default setting and allow a stretching.</li>
				<li>When implementing the method Draw of the view, it is
					useful to cast the input-parameter component
					to the corresponding class to have full access to
					the object. Note that the provided device-context dc
					is the device-context of the parent-control of the 
					drawable-object, hence the coordinates when doing the
					drawing are relative to the parent-control.</li>
				<li>When initializing a drawable-object, a
					pointer to the view-object must be provided
					in the constructor.</li>
			</ul>
		</p>
		
		[ Previous: <a href="gui_tutorial_05.html">Controls</a> ] [ Next: <a href="gui_tutorial_07.html">Device Context</a> ]
		
	</body>
</html>